{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Proxmoxer","text":""},{"location":"#welcome-to-proxmoxer","title":"Welcome to Proxmoxer","text":"<p>Proxmoxer is a wrapper around the APIs for Proxmox products.</p> <p>It was inspired by slumber, but it is dedicated only to Proxmox. It allows not only REST API use over HTTPS, but the same api over SSH. Like Proxmoxia, it dynamically creates attributes which responds to the attributes you've attempted to reach.</p>"},{"location":"#supported-services","title":"Supported Services","text":"<p>Below are the Proxmox services supported by this library.<sup>1</sup></p> <ul> <li>PVE (API Spec)</li> <li>PMG (API Spec)</li> <li>PBS (API Spec)</li> </ul>"},{"location":"#supported-backends","title":"Supported Backends (Connection Methods)","text":"<p>Below are the backends supported by this library.<sup>1</sup></p> <ul> <li>HTTPS</li> <li>SSH (openssh)</li> <li>SSH (ssh_paramiko)</li> <li>local</li> </ul> <p>View the Setup page for details on how to setup your environment for each backend.</p> <ol> <li> <p>The names of the services and backends can be in any case as the library will standardize the case to what it requires. e.g. \"hTtpS\" is just as valid as \"https\" or \"HTTPS\".\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"authentication/","title":"Authentication","text":"<p>To access a Proxmox service, you must first authenticate with the API. The method changes based on the chosen backend, user type, and credential type.</p>"},{"location":"authentication/#proxmox-api-permission-scopes","title":"Proxmox API Permission Scopes","text":"<p>To interact with a Proxmox service, the authentication credentials used must have the appropriate permissions. For more information, view the Proxmox documentation on permissions (e.g. PVE Permissions).</p>"},{"location":"authentication/#https-backend","title":"HTTPS Backend","text":"<p>The HTTPS is the universally accepted backend and supports the most authentication options. To ensure you are only sending your credentials encrypted and to the correct server, make sure to setup a valid SSL certificate and remove <code>verify_ssl=False</code> from your initialization of the ProxmoxAPI object.</p>"},{"location":"authentication/#username-and-password","title":"Username and Password","text":"<p>Supported Services: PVE, PMG, PBS</p> <p>Password authentication is the default authentication method and what is used by the web UI. To use this authentication method, the following data is needed:</p> <ul> <li>username</li> <li>realm (<code>pam</code>, <code>pve</code>, etc.)</li> <li>password</li> </ul> <p>For the <code>pve</code> realm, the password is set within the API/webUI. For other realms, the password is set in those tools (e.g. for the <code>pam</code> realm, the password is found in <code>/etc/passwd</code> (or really <code>/etc/shadow</code>) and can be set by running <code>passwd &lt;username&gt;</code> as root). If your user has a One Time Password (OTP) enabled, you will need to add the <code>otp</code> parameter and with your current OTP code to be able to authenticate. This is only required when first authenticating, as long as the requirements for authentication renewal are met (see below).</p> <pre><code>prox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;@&lt;realm&gt;', password='&lt;password&gt;', otp='&lt;otp_code&gt;', service='&lt;proxmox_service&gt;', verify_ssl=&lt;True|False&gt;, timeout=&lt;timeout_in_seconds&gt;)</code></pre> <p>For example:</p> <pre><code>prox = ProxmoxAPI('10.10.10.10', user='root@pam', password='password', verify_ssl=False)\n</code></pre>"},{"location":"authentication/#renewing-authentication","title":"Renewing Authentication","text":"<p>The authentication ticket retrieved using your username/password pair expires after 2 hours. To allow longer usage of proxmoxer, when a request is made close to the expiry of the ticket, the ticket is automatically renewed for another 2 hours. No user interaction is required for renewal and it will automatically be triggered by any request.</p> <p>If long-running usage of proxmoxer is required, the only requirement is to make a request within 2 hours of the most recent request. If the application will already make requests more regularly than 2 hours, no extra requests are needed to keep authentication valid. Any request will trigger an authentication renewal, so a basic <code>GET</code> (e.g. getting version) every hour or so is enough to keep authentication current. For an alternative, see API Tokens below for a stateless authentication method which allows fine-grain control over permissions and allows authentication expiry.</p> <p>Renewal also does not require OTP codes, so once initially authenticated with an OTP, proxmoxer can continue without user interaction.</p>"},{"location":"authentication/#api-token","title":"API Token","text":"<p>Supported Services: PVE, PBS</p> <p>The API Token allows stateless interaction with the Proxmox service as well as independent permissions and more flexibility in credential lifecycle management. Abused/leaked API Tokens can be disabled independent of the account with which they are associated and multiple API Tokens can be created for a user, allowing each use its own API Token with only its needed permissions which can be independently managed.</p> <pre><code>prox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;@&lt;realm&gt;', token_name='&lt;token_name&gt;', token_value='&lt;token_value&gt;', service='&lt;proxmox_service&gt;', verify_ssl=&lt;True|False&gt;, timeout=&lt;timeout_in_seconds&gt;)</code></pre> <p>For example:</p> <pre><code>prox = ProxmoxAPI('10.10.10.10', user='my_user@pam', token_name='testToken', token_value='41c97f11-b8c6-47db-9886-7fa841e64b6e', verify_ssl=False)</code></pre>"},{"location":"authentication/#openssh-backend","title":"OpenSSH Backend","text":"<p>Supported Services: PVE, PMG</p> <p>The OpenSSH backend uses OpenSSH to remote into the Proxmox service and run the command using the service's CLI interface. This backend will default to using the config and key of the ssh client (usually in <code>~/.ssh/</code>), so often only needs a host and a user. As this uses SSH to log into the service, it can be considered to use the \"pam\" realm and the specified user must have permission to connect and run the appropriate commands. If the user does not natively have permission to run the required commands, adding an argument of <code>sudo=True</code> will prepend <code>sudo</code> to the command so the specified user can elevate privileges.</p>"},{"location":"authentication/#minimal-required-arguments","title":"Minimal Required Arguments","text":"<pre><code>prox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;', backend='openssh')</code></pre>"},{"location":"authentication/#all-openssh-arguments","title":"All OpenSSH Arguments","text":"<pre><code>prox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;', port=&lt;port_number&gt;, sudo=&lt;True|False&gt;, forward_ssh_agent=&lt;True|False&gt;, config_file='&lt;path_to_config_file&gt;', identity_file='&lt;path_to_identity_file&gt;', timeout=&lt;timeout_in_seconds&gt;, backend='openssh')</code></pre> <p>For example:</p> <pre><code>prox = ProxmoxAPI('10.10.10.10', user='my_user', sudo=True, backend='openssh')</code></pre>"},{"location":"authentication/#paramiko","title":"Paramiko","text":"<p>Supported Services: PVE, PMG</p> <p>Paramiko is an implementation of SSH completely in Python. This reduces some of the available functionality, but increases portability and reduces dependencies on outside programs. This backend supports password and key authentication.</p> <p>Paramiko uses the following order to attempt authentication:<sup>1</sup></p> <ul> <li>private_key_file</li> <li>SSH Agent</li> <li>Auto-discovered key files</li> <li>Password</li> </ul>"},{"location":"authentication/#key","title":"Key","text":"<p>Paramiko defaults to looking for in <code>~/.ssh</code> for openssh-style key file names. If a <code>private_key_file</code> argument is present, it is used before any keys automatically found.</p> <pre><code>prox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;', private_key_file='&lt;path_to_file&gt;', backend='ssh_paramiko')</code></pre>"},{"location":"authentication/#password","title":"Password","text":"<p>If a password is provided, usage of an SSH agent is disabled.</p> <pre><code>prox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;', password='&lt;password&gt;', backend='ssh_paramiko')</code></pre>"},{"location":"authentication/#all-paramiko-arguments","title":"All Paramiko Arguments","text":"<pre><code>prox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;', password='&lt;password&gt;', port=&lt;port&gt;, private_key_file='&lt;path_to_file&gt;', timeout=&lt;timeout_in_seconds&gt;, sudo=&lt;True|False&gt;, backend='ssh_paramiko')</code></pre>"},{"location":"authentication/#local","title":"Local","text":"<p>The local backend requires no authentication, other than optionally utilizing sudo.</p> <pre><code>prox = ProxmoxAPI(sudo=&lt;True|False&gt;, timeout=&lt;timeout_in_seconds&gt;, backend='local')</code></pre> <ol> <li> <p>https://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.connect \u21a9</p> </li> </ol>"},{"location":"basic_usage/","title":"Basic Usage","text":""},{"location":"basic_usage/#basic-usage","title":"Basic Usage","text":"<p>Proxmoxer is easy to use. After importing the library and creating an instance, interacting with the Proxmox service is simple and follows the API documentation.</p>"},{"location":"basic_usage/#importing-and-creating-an-instance","title":"Importing and Creating an Instance","text":"Example Data <p>In the examples below (and in the rest of the documentation), placeholders are used for values which will be different between installations. Anything within <code>&lt;&gt;</code> is a value you will need to change for your environment. There may be some additional examples of what a command might look like with actual values.</p> <p>Any time <code>&lt;&gt;</code> will be used not as placeholders, a note like this will explain the usage for that case.</p> <p>To use Proxmoxer, the library must be imported and a ProxmoxerAPI instance created. This instance takes care of all the authentication, abstraction, and de-serialization of the API calls.</p> <pre><code>from proxmoxer import ProxmoxAPI\n\nproxmox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;@&lt;realm&gt;', password='&lt;password&gt;', verify_ssl=False)</code></pre> <p><code>verify_ssl</code> Parameter</p> <p>If you have set up valid SSL certificates, you can remove the <code>verify_ssl=False</code>, but the default self-signed certificates will throw an error without <code>verify_ssl=False</code>.</p>"},{"location":"basic_usage/#switching-services-or-backends","title":"Switching Services or Backends","text":"<p>This will default to connecting to a 'PVE' service using the <code>https</code> backend. To change these defaults, specify a <code>service</code> or <code>backend</code> parameter of a supported service and/or a supported backend.</p> <p>e.g. <code>proxmox = ProxmoxAPI('&lt;host_ip_or_domain&gt;', user='&lt;username&gt;', backend='openssh', service='pmg')</code></p>"},{"location":"basic_usage/#changing-ports","title":"Changing Ports","text":"<p>Proxmoxer (when using the https backend) will use the default port for the selected service to connect to the service. If you need to connect on a different port, adding either the <code>port=&lt;port_number&gt;</code> parameter or adding <code>:&lt;port&gt;</code> to the host can be used. A port in the host will override the <code>port</code> parameter. The <code>port</code> parameter can also be used for the SSH-based backends to change the port used to establish a SSH connection.</p>"},{"location":"basic_usage/#making-api-calls","title":"Making API Calls","text":"<p>There are two ways to build API requests: dotted notation and string notation. The format and benefits of each are presented below.</p>"},{"location":"basic_usage/#dotted-notation","title":"Dotted Notation","text":"<p>Dotted notation can be thought of as treating the API call as a collection of dicts. This means that you can specify the API endpoint in a pythonic manner and let proxmoxer take care of converting to what the Proxmox service requires.</p> <p>Lets say you want to see what users are available and what containers are on the \"example-node\" node and that <code>prox</code> is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples).</p> <pre><code>&gt;&gt;&gt; # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users\n&gt;&gt;&gt; prox.access.users.get()\n[{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}]</code></pre> <p>To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below).</p> <pre><code>&gt;&gt;&gt; # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc\n&gt;&gt;&gt; prox.nodes(\"example-node\").lxc.get()\n[{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}]</code></pre> <p>To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each.</p> <pre><code>&gt;&gt;&gt; # get the list of all the nodes available from the connected node\n&gt;&gt;&gt; print(proxmox.nodes.get())\n[{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}]\n&gt;&gt;&gt; # use the list of nodes to iterate through each and print the containers and their status\n&gt;&gt;&gt; for pve_node in proxmox.nodes.get():\n...     print(\"{0}:\".format(pve_node['node']))\n...     for container in proxmox.nodes(pve_node['node']).lxc.get():\n...         print(\"\\t{0}. {1} =&gt; {2}\".format(container['vmid'], container['name'], container['status']))\n... \nexample-node:\n        100. container-a =&gt; running\n        101. container-b =&gt; running\n        105. container-c =&gt; running</code></pre>"},{"location":"basic_usage/#string-notation","title":"String Notation","text":"<p>String notation allows the developer to specify the exact URL path to be used for the API call. This puts more responsibility on the developer to correctly format the path but gives ultimate configurability. The dotted notation examples are displayed below converted into string notation.</p> <p>Lets say you want to see what users are available and what containers are on the \"example-node\" node and that <code>prox</code> is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples).</p> <pre><code>&gt;&gt;&gt; # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users\n&gt;&gt;&gt; prox(\"access/users\").get()\n[{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}]</code></pre> <p>To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below).</p> <pre><code>&gt;&gt;&gt; # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc\n&gt;&gt;&gt; prox(\"nodes/example-node/lxc\").get()\n[{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}]</code></pre> <p>To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each.</p> <pre><code>&gt;&gt;&gt; # get the list of all the nodes available from the connected node\n&gt;&gt;&gt; print(proxmox(\"nodes\").get())\n[{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}]\n&gt;&gt;&gt; # use the list of nodes to iterate through each and print the containers and their status\n&gt;&gt;&gt; for pve_node in proxmox.nodes.get():\n...     print(\"{0}:\".format(pve_node['node']))\n...     for container in proxmox(\"nodes/{0}/lxc\".format(pve_node['node'])).get():\n...         print(\"\\t{0}. {1} =&gt; {2}\".format(container['vmid'], container['name'], container['status']))\n... \nexample-node:\n        100. container-a =&gt; running\n        101. container-b =&gt; running\n        105. container-c =&gt; running</code></pre>"},{"location":"basic_usage/#combining-dotted-and-string-notation","title":"Combining Dotted and String Notation","text":"<p>There are a few situations where combining the notations is required or more effective.</p>"},{"location":"basic_usage/#variable-data","title":"Variable Data","text":"<p>As mentioned in the Dotted Notation section, there are times when string notation is needed in combination with dotted notation.</p>"},{"location":"basic_usage/#invalid-names-in-python","title":"Invalid Names In Python","text":"<p>Some endpoints in the Proxmox APIs include a hyphen (\"-\"). When using dotted notation, python interprets this as subtraction rather than a hyphen in the name. In this case, string notation can be used for that section of the path and using dotted notation for the rest of the path.</p> <p>For example, if you want to check the status of a command running in a VM, you would need to do the following</p> <pre><code>&gt;&gt;&gt; # using https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/qemu/{vmid}/agent/exec-status\n&gt;&gt;&gt; prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec\").post(command=\"echo hello\")\n{'pid': 5413}\n&gt;&gt;&gt; prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec-status\").get(pid=5413)\n{'out-data': 'hello\\n', 'exited': 1, 'exitcode': 0}</code></pre>"},{"location":"basic_usage/#examples","title":"Examples","text":"<p>The following are all different ways of calling the same API path and will return the same result.</p> <pre><code>prox.nodes(&lt;node_name&gt;).lxc.get()\nprox.nodes(&lt;node_name&gt;).get('lxc')\nprox.get('nodes/%s/lxc' % &lt;node_name&gt;)\nprox.get('nodes', &lt;node_name&gt;, 'lxc')\nprox('nodes')(&lt;node_name&gt;).lxc.get()\nprox(['nodes', &lt;node_name&gt;]).lxc.get()\nprox(['nodes', &lt;node_name&gt;]).get('lxc')\nprox('nodes')(&lt;node_name&gt;)('lxc').get()</code></pre>"},{"location":"development/","title":"Development","text":"<p>Stub Page</p> <p>This page may be incomplete or contain partial information.</p> <p>Please help improve this page by clicking the edit button above and submitting a Pull Request (PR) to expand this page.</p>"},{"location":"development/#installing-from-source","title":"Installing from Source","text":"<p>Sometimes there are features that have not been added to a published version in PyPI but are in the development source code in Git. You can install directly from the source code branches to test these features or develop more on them.</p> <p>Stability not guaranteed</p> <p>Installing from source control (Git) branches is inherently less stable than installing from PyPI. Installing like this will also not update when new versions or commits are published. Code in source control may be incomplete or broken. No support will be given for issues that arise from installing in this way, however bug reports of broken code are appreciated.</p> <p>There are two main branches to install from:</p> <ul> <li>master<ul> <li>This branch is what the PyPI versions are built from</li> <li>This branch should be as stable as the PyPI versions, so installing from here is unnecessary</li> </ul> </li> <li>develop<ul> <li>This branch contains the improvements and new features which will be bundled into a future version</li> <li>This branch should be mostly stable, but can have bugs which are removed before bundled into a version</li> <li>Installing from this branch allows using the latest features and bug testing them</li> </ul> </li> </ul> <p>To install from source control, use <code>git+https://github.com/proxmoxer/proxmoxer.git@&lt;branch&gt;</code>. You will most likely need to specify the <code>-U</code> (<code>--upgrade</code>) flag to overwrite the existing version with the source control version. For example:</p> <pre><code>pip install --upgrade git+https://github.com/proxmoxer/proxmoxer.git@develop</code></pre> <p>More information from installing from source control can be found in the VCS Support pip documentation.</p>"},{"location":"development/#developing-using-dev-containers","title":"Developing using Dev Containers","text":"<p>If you use Visual Studio Code for development, you can utilize the great Containers remote to use a containerize development environment. This allows you to use a specific python version or install any packages without interfering with any other development environments you may have. And if you mess anything up or are done contributing, you can simply delete the container and volume and the entire codebase and dependencies are cleaned up.</p> <ol> <li>Install Docker (Instructions)</li> <li>Install Visual Studio Code (Instructions)</li> <li>Install the \"Remote - Containers\" extension</li> <li>Clone this repository into a container (Instructions)</li> <li>Wait for the configuration to be loaded, dependencies installed, setup completed, and suggested extensions installed</li> </ol> <p>Now you can use the included tasks, linters, and testing support to easily develop on any platform.</p>"},{"location":"development/#developing-using-manual-installation","title":"Developing using Manual Installation","text":"<p>If you use another development environment or just don't want to use devcontainers, use the steps below to get started developing Proxmoxer.</p> <ol> <li>Install Python 3 (Instructions)</li> <li>Install Pip for Python 3 (Instructions)</li> <li>clone this repo with <code>git clone https://github.com/proxmoxer/proxmoxer.git</code> and change into the <code>proxmoxer</code> directory</li> <li>Install dependencies with <code>pip3 install --user -r test_requirements.txt -r dev_requirements.txt</code></li> </ol>"},{"location":"setup/","title":"Setup","text":"<p>Proxmoxer is easy to setup and has minimal dependencies.</p>"},{"location":"setup/#choosing-a-backend","title":"Choosing a Backend","text":"<p>The required dependencies change depending on the backend (connection method) you will use. The HTTPS backend better matches the details in the Proxmox API documentation, but SSH can be used in an (mostly) interchangeable manner. SSH can be used with complex network environments and can be used with jump hosts. The HTTPS backend can be used through a reverse proxy or any other HTTPS manipulation scheme.</p> <p>For most users, the HTTPS backend will be suitable. The HTTPS backend allows connections for non-PAM realm accounts and supports advanced authentication methods such as API Tokens. It is also universally supported across all current Proxmox products. Unless SSH is specifically required, it is advised to use the HTTPS backend.</p>"},{"location":"setup/#installing-dependencies","title":"Installing Dependencies","text":"<p>In addition to installing the <code>proxmoxer</code> package via pip, the following packages are required for each backend.</p> httpsopensshssh_paramiko <p><code>pip install requests</code></p> <p>If you will be uploading files, installing <code>requests_toolbelt</code> will automatically allow larger upload file sizes and reduce memory footprint of an upload</p> <p><code>pip install openssh_wrapper</code></p> <p><code>pip install paramiko</code></p> <p>You can, of course, install all the dependencies with <code>pip install requests requests_toolbelt openssh_wrapper paramiko</code> to be able to use any of the backends.</p>"},{"location":"v1_migration/","title":"Migrating from Version 1","text":"<p>There are a few breaking changes between version 1 and version 2.</p>"},{"location":"v1_migration/#authenticationerror-moved","title":"<code>AuthenticationError</code> Moved","text":"<p><code>proxmoxer.backends.https.AuthenticationError</code> was moved to <code>proxmoxer.AuthenticationError</code> (the class itself is the same). Any imports or references to <code>proxmoxer.backends.https.AuthenticationError</code> should be changed to <code>proxmoxer.AuthenticationError</code>.</p>"},{"location":"v1_migration/#proxmoxresourcebase-removed","title":"<code>ProxmoxResourceBase</code> Removed","text":"<p>While this should be a fully internal change, the <code>ProxmoxResourceBase</code> class was removed. Use <code>ProxmoxResource</code> instead.</p>"},{"location":"v1_migration/#removed-proxmoxhttpticketauth","title":"Removed <code>ProxmoxHTTPTicketAuth</code>","text":"<p>The <code>auth_token</code> and <code>csrf_token</code> arguments are no longer supported. If an existing (still valid) token needs to be used, you can pass the token as <code>password</code> and proxmoxer will attempt to renew the ticket and retrieve a new token and CSRF token.</p>"},{"location":"v1_migration/#testing-changed-to-pytest","title":"Testing changed to pytest","text":"<p>The unit testing framework was transitioned from nose to pytest. Any integration with the proxmoxer tests should now call pytest.</p>"},{"location":"examples/cloud-init/","title":"Cloud-init","text":""},{"location":"examples/cloud-init/#configuring-new-vms-with-cloud-init","title":"Configuring new VMs with Cloud-init","text":""},{"location":"examples/cloud-init/#what-does-cloud-init-do","title":"What does Cloud-init do?","text":"<p>Cloud-init is the industry standard for customizing guest operating systems on virtual infrastructure platforms such as Proxmox PVE.</p> <p>This customization stage occurs during the first boot of the guest operating system, where an initialization agent (such as cloud-init) looks for a so-called \"cloud-config\" data source (usually just a YAML file transparently served from a reserved IP class or locally attached ISO image), and applies the various settings specified within said cloud config (e.g. creating a new user).</p>"},{"location":"examples/cloud-init/#cloud-init-settings-on-proxmox-pve","title":"Cloud-init settings on Proxmox PVE","text":"<p>The Proxmox PVE API allows users to set specific properties within the cloud config to be used during the initial run of Cloud-init within the guest OSes on first boot, such as:</p> <ul> <li>Specifying a new username/password/SSH keys which will get automatically   created.</li> <li>Specifying IPv4/6 configurations to be applied within the guest OS.</li> <li>Some additional options, such as performing automatic package manager updates   on Linux guests, static networking settings, and more.</li> </ul>"},{"location":"examples/cloud-init/#template-prerequisites","title":"Template Prerequisites","text":"<p>In order for the Cloud-init instance options to be applied, the VM image being booted must have a pre-installed agent which is able to read the the cloud config data format.</p>"},{"location":"examples/cloud-init/#linux-templates","title":"Linux templates","text":"<p>On Linux guests, the so-called <code>nocloud</code> data source is used to pass the cloud config to the guest OS, so the Cloud-init installation within the VM image being booted must be configured to use it.</p> <p>In most situations, using pre-baked Linux \"golden images\" (such as the upstream Canonical Ubuntu Server images) should work out of the box, though some additional pre-customization (such as installing the <code>qemu-guest-agent</code>) might be required for better compatibility with PVE.</p>"},{"location":"examples/cloud-init/#windows-templates","title":"Windows templates","text":"<p>For Windows guests, the industry-standard initialization agent implementation is Cloudbase-init.</p> <p>On Windows guests, the so-called <code>configdrive2</code> data source is used to pass the cloud config to the guest OS, so the Windows image must have Cloudbase-init configured to use it.</p> <p>Issues on Windows</p> <p>as of the time of writing, there are some known issues with the formatting of some fields of the cloud-config for Windows guests (most notably, the inability set passwords through the cloud-config).</p>"},{"location":"examples/cloud-init/#example-code-setting-cloud-init-options","title":"Example code setting cloud-init options","text":"<p>The current PVE API allows for the transparent configuration of a number of guest initialization options via the VM's <code>config</code> properties.</p> <ul> <li><code>ciuser</code> (str): new username to create on first boot.</li> <li><code>cipassword</code> (str): new password for the above <code>ciuser</code>.</li> <li><code>sshkeys</code> (str): public SSH keys to be automatically added as authorized for   the above <code>ciuser</code>.</li> <li><code>ciupgrade</code> (bool): whether or not to automatically update packages on first   boot. NOTE: the default is <code>True</code>, and it may negatively impact applications   expecting fixed dependency versions.</li> <li><code>cicustom</code> (str): allows for specifying the entirety of the Cloud-init config file.</li> <li><code>ipconfigN</code> (str): specifies IP settings for the guests network interface   with index <code>N</code> (e.g. <code>ip=192.168.125.25/32,gw=192.168.0.1</code>). Omitting this will   have cloud-init attempt DHCPv4 on said interface.</li> <li><code>nameserver</code> (str): list of DNS nameservers to configure within the guest.</li> <li><code>searchdomain</code> (str): DNS search domain to use. Omitting this will have the   VM inherit the hosting Proxmox node's search domain. (if any)</li> </ul> <pre><code># NOTE: please remember that the template must have Cloud-init (or equivalent)\n# pre-installed and pre-configured for first boot. (see above template sections)\nTEMPLATE_ID = 200\n\nclone_vm_id = int(proxmox.cluster.nextid.get())\nclone_task = proxmox.nodes(\"&lt;node_name&gt;\").qemu(TEMPLATE_ID).clone.create(newid=clone_vm_id)\n\n# NOTE: should either wait a fixed time for the clone to complete, or check the status of the clone task\n#time.sleep(10)\nfrom proxmoxer.tools import Tasks\nTasks.blocking_status(proxmox, clone_task)\n\n# NOTE: the `sshkeys` attribute requires manual urlencoding on our end.\n# Please see https://github.com/proxmoxer/proxmoxer/issues/153.\nfrom urllib import parse as urlparse\n\nSSH_KEYS = \"ssh-rsa ...\"  # contents of '~/ssh/id_rsa.pub'\n# NOTE: by default safe='/' so we have to pass safe='' to clear it.\nENCODED_KEYS = urlparse.quote(SSH_KEYS, safe='')\n\n# Set the userdata as desired BEFORE starting the machine:\nproxmox.nodes(\"&lt;node_name&gt;\").qemu(clone_vm_id).config.set(\n    ciuser=\"&lt;new_username&gt;\",\n    cipassword=\"&lt;new_password&gt;\",\n    sshkeys=ENCODED_KEYS,\n    ciupgrade=False,\n    cicustom=\"&lt;explicit YAML cloud-config&gt;\",\n    ipconfig0=\"ip=192.168.125.25/32,gw=192.168.0.1\",\n    nameserver=\"1.1.1.1\",\n    searchdomain=\"example.com\",\n)\n\n# Start the machine normally, and give cloud-init a minute for its initial run.\n# You should be able to see cloud-init's logs within the VM console in the PVE UI.\nproxmox.nodes(\"&lt;node_name&gt;\").qemu(clone_vm_id).status.start()</code></pre>"},{"location":"examples/files/","title":"Sending Files","text":""},{"location":"examples/files/#files","title":"Files","text":""},{"location":"examples/files/#uploading-files-to-pve","title":"Uploading Files to PVE","text":"<p>If you have files on your device which you want to upload to your PVE, it is easy to do.</p> <p>First, to upload large file and to prevent high memory usage, install the <code>requests_toolbelt</code> pip package (<code>pip install requests_toolbelt</code>).</p> <p>Next, you will need to open the file you want to upload.</p> <pre><code>f = open(\"&lt;file_path&gt;\", \"rb\")</code></pre> <p>Finally, upload the file specifying the correct <code>content</code> type (\"template\" or \"iso\").</p> <pre><code>prox.proxmox.nodes('&lt;node_name&gt;').storage('&lt;storage_name&gt;').upload.post(content='&lt;content_type&gt;', filename=f)</code></pre>"},{"location":"examples/files/#downloading-files-to-pve","title":"Downloading Files to PVE","text":"<p>As an alternative to downloading a file to your computer and then uploading it to your PVE instance, you can request PVE directly download the file from its URL.</p> <p>Assuming <code>prox</code> is a valid <code>ProxmoxerAPI</code> object and <code>sourceURL</code> is a complete URL of a file to download. <code>content</code> is the same options as above and <code>filename</code> is the name the file will be saved as on the PVE storage.</p> <pre><code>proxmox.nodes(\"&lt;node_name&gt;\").storage(\"&lt;storage_name&gt;\")(\"download-url\").post(url=sourceURL, content=\"&lt;content_type&gt;\", filename=\"&lt;file_name.extension&gt;\")</code></pre> <p>To ensure the file downloaded is the file you expect, you can also specify a hash and algorithm which PVE will check against the file it downloads.</p> <pre><code>proxmox.nodes(\"&lt;node_name&gt;\").storage(\"&lt;storage_name&gt;\")(\"download-url\").post(url=sourceURL, content=\"&lt;content_type&gt;\", filename=\"&lt;file_name.extension&gt;\", \n    checksum=\"&lt;hash&gt;\", \"checksum-algorithm\": \"&lt;md5 | sha1 | sha224 | sha256 | sha384 | sha512&gt;\")</code></pre> <p>This post request will return the UPID of the task created for that download. To wait (block) until a download is complete, see the Blocking Until Task is Complete section.</p>"},{"location":"examples/tasks/","title":"Tasks","text":""},{"location":"examples/tasks/#tasks","title":"Tasks","text":""},{"location":"examples/tasks/#basic-task-interaction","title":"Basic Task Interaction","text":""},{"location":"examples/tasks/#what-is-a-task-upid","title":"What is a task UPID?","text":"<p>Most actions on Proxmox services are backed by tasks. These are visible in the web UI and are created when automation or users request actions be completed.</p> <p>Tasks are uniquely identified by a UPID which follows the format</p> <pre><code>UPID:&lt;node_name&gt;:&lt;pid_in_hex&gt;:&lt;pstart_in_hex&gt;:&lt;starttime_in_hex&gt;:&lt;type&gt;:&lt;id (optional)&gt;:&lt;user&gt;@&lt;realm&gt;:</code></pre> <p>For example <code>UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam:</code> or <code>UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam:</code>.</p>"},{"location":"examples/tasks/#getting-task-ids","title":"Getting Task IDs","text":"<p>The Proxmoxer service instance will maintain a record of all past tasks as well as all currently active tasks. The list of these tasks can be requested.</p> <pre><code>&gt;&gt;&gt; prox.nodes(\"example-node\").tasks.get(limit=3, source=\"all\")\n[{'id': '103', 'user': 'root@pam', 'pstart': 65597267, 'saved': '0', 'type': 'vzdump', 'pid': 851962, 'upid': 'UPID:example-node:000CFFFA:03E8EF53:619480BA:vzdump:103:root@pam:', 'node': 'example-node', 'starttime': 1637122234, 'status': 'RUNNING'}, {'user': 'root@pam', 'endtime': 1637122161, 'id': '', 'upid': 'UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'node': 'example-node', 'starttime': 1637122156, 'status': 'OK', 'type': 'aptupdate', 'pid': 851036, 'pstart': 65589443}, {'endtime': 1637121960, 'id': '', 'user': 'root@pam', 'pstart': 65550050, 'pid': 848306, 'type': 'vncshell', 'starttime': 1637121762, 'upid': 'UPID:example-node:000CF1B2:03E836E2:61947EE2:vncshell::root@pam:', 'node': 'example-node', 'status': 'OK'}]</code></pre> <p>Additional filters can be found in the documentation.</p>"},{"location":"examples/tasks/#getting-task-details","title":"Getting Task Details","text":"<p>Each task has associated information on the status of the task and a log of the output of the task. This data can be collected by using the UPID of the task.</p> <pre><code>&gt;&gt;&gt; prox.nodes(\"example-node\").tasks(\"UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").status.get()\n{'pid': 851036, 'node': 'example-node', 'type': 'aptupdate', 'upid': 'UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'status': 'stopped', 'starttime': 1637122156, 'pstart': 65589443, 'id': '', 'exitstatus': 'OK', 'user': 'root@pam'}\n&gt;&gt;&gt; prox.nodes(\"example-node\").tasks(\"UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").log.get()\n[{'n': 1, 't': 'starting apt-get update'}, {'t': 'Hit:1 http://ftp.us.debian.org/debian bullseye InRelease', 'n': 2}, {'n': 3, 't': 'Get:2 http://ftp.us.debian.org/debian bullseye-updates InRelease [39.4 kB]'}, {'t': 'Get:3 http://security.debian.org bullseye-security InRelease [44.1 kB]', 'n': 4}, {'n': 5, 't': 'Get:4 http://download.proxmox.com/debian/pve bullseye InRelease [3053 B]'}, {'t': 'Fetched 86.5 kB in 1s (125 kB/s)', 'n': 6}, {'t': 'Reading package lists...', 'n': 7}, {'t': 'TASK OK', 'n': 8}]</code></pre> <p>The status information (for completed tasks) includes information on who, when, where, and what was done in that task. The log contains a list of dicts which are <code>{'n': &lt;int_of_line_number&gt;, 't': '&lt;line_text&gt;'}</code>, one for each line of output.</p>"},{"location":"examples/tasks/#tasks-in-progress","title":"Tasks in Progress","text":"<p>While tasks are active, the <code>status</code> endpoint returns information on the setup and start of the task and a status or \"running\".</p>"},{"location":"examples/tasks/#blocking-until-task-is-complete","title":"Blocking Until Task is Complete","text":"<p>Many API endpoints will return a task UPID while the task completes in the background. While this can be useful to allow asynchronous execution, often you may desire to wait (block) for a task to finish.</p> <p>The code below provides a (very) basic way of polling the API until the task completes.</p> <pre><code>\ndef basic_blocking_task_status(proxmox_api, task_id, node_name):\n    data = {\"status\": \"\"}\n    while (data[\"status\"] != \"stopped\"):\n        data = proxmox_api.nodes(node_name).tasks(task_id).status.get()\n\n    return data</code></pre>"},{"location":"tools/intro/","title":"Intro to Tools","text":"<p>The <code>proxmoxer.tools</code> package is a collection of convenience classes which assist with common use-cases.  These classes are not required to use proxmoxer (or even the Proxmox features they support), but provide common code which you would likely just recreate when using the features.</p>"},{"location":"tools/intro/#classes","title":"Classes","text":"<ul> <li>Tasks - Interact with Proxmox Tasks and UPIDs</li> </ul>"},{"location":"tools/tasks/","title":"Tasks Tools","text":""},{"location":"tools/tasks/#what-is-a-task-upid","title":"What is a task UPID?","text":"<p>Most actions on Proxmox services are backed by tasks. These are visible in the web UI and are created when automation or users request actions be completed.</p> <p>Tasks are uniquely identified by a UPID which follows the format</p> <pre><code>UPID:&lt;node_name&gt;:&lt;pid_in_hex&gt;:&lt;pstart_in_hex&gt;:&lt;starttime_in_hex&gt;:&lt;type&gt;:&lt;id (optional)&gt;:&lt;user&gt;@&lt;realm&gt;:</code></pre>"},{"location":"tools/tasks/#class-methods","title":"Class Methods","text":"<p>The functionality of the Tasks tools class is available through static methods. This means you don not need to instantiate a Tasks object to be able to call the methods.</p>"},{"location":"tools/tasks/#blocking_status","title":"blocking_status","text":"<p>Turns getting the status of a Proxmox task into a blocking call by polling the API until the task completes.</p> <ul> <li><code>prox</code> (ProxmoxAPI) - The ProxmoxAPI object to use to query for status</li> <li><code>task_id</code> (str) - the UPID of the task</li> <li><code>timeout</code> (float, optional) - If the task does not complete in this time (in seconds) return None, defaults to 300</li> <li><code>polling_interval</code> (float, optional) - the time to wait between checking for status updates, defaults to 0.01</li> </ul>"},{"location":"tools/tasks/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from proxmoxer.tools import Tasks\n&gt;&gt;&gt; from proxmoxer import ProxmoxAPI\n&gt;&gt;&gt; prox = ProxmoxAPI(\"1.2.3.4\", user=\"root@pam\", password=\"password\", verify_ssl=False)\n&gt;&gt;&gt; Tasks.blocking_status(prox, \"UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:\")\n{'pstart': 235991182, 'exitstatus': 'OK', 'pid': 3017066, 'user': 'root@pam', 'starttime': 1669517921, 'upid': 'UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:', 'type': 'vzcreate', 'node': 'hydrogen-pve-0', 'id': '123', 'status': 'stopped'}\n&gt;&gt;&gt;</code></pre>"},{"location":"tools/tasks/#decode_upid","title":"decode_upid","text":"<p>Decodes the sections of a UPID into separate fields</p> <ul> <li><code>upid</code> (str) - a UPID string</li> <li>returns dict of UPID sections<ul> <li><code>upid</code> (str) - the original upid</li> <li><code>node</code> (str) - the name of the node which started/owns the task</li> <li><code>pid</code> (int) - the process ID of the task</li> <li><code>pstart</code> (int) - the relative timestamp of the start of the process</li> <li><code>starttime</code> (int) - the epoch timestamp of the start of the task</li> <li><code>type</code> (str)  - the type of task represented by the UPID</li> <li><code>id</code> (str) - an identifier additional to the type (usually the resource (e.g. VM) ID)</li> <li><code>user</code> (str) - The <code>&lt;user&gt;@&lt;realm&gt;</code> who initiated the task</li> <li><code>comment</code> (str) - an optional extra field, often not used</li> </ul> </li> </ul>"},{"location":"tools/tasks/#examples_1","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from proxmoxer.tools import Tasks\n&gt;&gt;&gt; Tasks.decode_upid(\"UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam:\")\n{'upid': 'UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam:', 'node': 'example-node', 'pid': 715154, 'pstart': 10623911, 'starttime': 1636572501, 'type': 'vzdump', 'id': '100', 'user': 'root@pam', 'comment': ''}\n&gt;&gt;&gt; Tasks.decode_upid(\"UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam:\")\n{'upid': 'UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam:', 'node': 'example-node', 'pid': 2178359, 'pstart': 32287149, 'starttime': 1636789133, 'type': 'aptupdate', 'id': '', 'user': 'root@pam', 'comment': ''}\n&gt;&gt;&gt;</code></pre>"},{"location":"tools/tasks/#decode_logs","title":"decode_logs","text":"<p>Decodes the JSON log of Proxmox tasks to a plain string. Joins the lines with <code>\\n</code>.</p> <p><code>log_list</code> (dict[]) - the list of log lines which is returned from the Proxmox service returns a string</p>"},{"location":"tools/tasks/#examples_2","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from proxmoxer.tools import Tasks\n&gt;&gt;&gt; from proxmoxer import ProxmoxAPI\n&gt;&gt;&gt; l = prox.nodes(\"example-node\").tasks(\"UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:\").log.get()\n&gt;&gt;&gt; l\n[{'t': \"extracting archive '/mnt/pve/hl01-files/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst'\", 'n': 1}, {'t': 'Total bytes read: 508579840 (486MiB, 194MiB/s)', 'n': 2}, {'t': 'Detected container architecture: amd64', 'n': 3}, {'t': \"Creating SSH host key 'ssh_host_rsa_key' - this may take some time ...\", 'n': 4}, {'n': 5, 't': 'done: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container'}, {'n': 6, 't': \"Creating SSH host key 'ssh_host_dsa_key' - this may take some time ...\"}, {'n': 7, 't': 'done: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container'}, {'n': 8, 't': \"Creating SSH host key 'ssh_host_ed25519_key' - this may take some time ...\"}, {'n': 9, 't': 'done: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container'}, {'n': 10, 't': \"Creating SSH host key 'ssh_host_ecdsa_key' - this may take some time ...\"}, {'n': 12, 't': 'TASK OK'}, {'t': 'done: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container', 'n': 11}]\n&gt;&gt;&gt; Tasks.decode_log(l)\n\"extracting archive '/mnt/pve/nas/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst'\\nTotal bytes read: 508579840 (486MiB, 194MiB/s)\\nDetected container architecture: amd64\\nCreating SSH host key 'ssh_host_rsa_key' - this may take some time ...\\ndone: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container\\nCreating SSH host key 'ssh_host_dsa_key' - this may take some time ...\\ndone: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container\\nCreating SSH host key 'ssh_host_ed25519_key' - this may take some time ...\\ndone: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container\\nCreating SSH host key 'ssh_host_ecdsa_key' - this may take some time ...\\ndone: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container\\nTASK OK\"\n&gt;&gt;&gt; print(Tasks.decode_log(l))\nextracting archive '/mnt/pve/nas/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst'\nTotal bytes read: 508579840 (486MiB, 194MiB/s)\nDetected container architecture: amd64\nCreating SSH host key 'ssh_host_rsa_key' - this may take some time ...\ndone: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container\nCreating SSH host key 'ssh_host_dsa_key' - this may take some time ...\ndone: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container\nCreating SSH host key 'ssh_host_ed25519_key' - this may take some time ...\ndone: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container\nCreating SSH host key 'ssh_host_ecdsa_key' - this may take some time ...\ndone: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container\nTASK OK\n&gt;&gt;&gt;</code></pre>"}]}