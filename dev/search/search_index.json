{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Proxmoxer \u00b6 Proxmoxer is a wrapper around the APIs for Proxmox products. It was inspired by slumber, but it is dedicated only to Proxmox. It allows not only REST API use over HTTPS, but the same api over SSH. Like Proxmoxia , it dynamically creates attributes which responds to the attributes you've attempted to reach. Supported Services \u00b6 Below are the Proxmox services supported by this library. 1 PVE ( API Spec ) PMG ( API Spec ) PBS ( API Spec ) Supported Backends (Connection Methods) \u00b6 Below are the backends supported by this library. 1 HTTPS SSH (openssh) SSH (ssh_paramiko) local View the Setup page for details on how to setup your environment for each backend. The names of the services and backends can be in any case as the library will standardize the case to what it requires. e.g. \"hTtpS\" is just as valid as \"https\" or \"HTTPS\". \u21a9 \u21a9","title":"Welcome to Proxmoxer"},{"location":"#welcome-to-proxmoxer","text":"Proxmoxer is a wrapper around the APIs for Proxmox products. It was inspired by slumber, but it is dedicated only to Proxmox. It allows not only REST API use over HTTPS, but the same api over SSH. Like Proxmoxia , it dynamically creates attributes which responds to the attributes you've attempted to reach.","title":"Welcome to Proxmoxer"},{"location":"#supported-services","text":"Below are the Proxmox services supported by this library. 1 PVE ( API Spec ) PMG ( API Spec ) PBS ( API Spec )","title":"Supported Services"},{"location":"#supported-backends","text":"Below are the backends supported by this library. 1 HTTPS SSH (openssh) SSH (ssh_paramiko) local View the Setup page for details on how to setup your environment for each backend. The names of the services and backends can be in any case as the library will standardize the case to what it requires. e.g. \"hTtpS\" is just as valid as \"https\" or \"HTTPS\". \u21a9 \u21a9","title":"Supported Backends (Connection Methods)"},{"location":"authentication/","text":"Authentication \u00b6 To access a Proxmox service, you must first authenticate with the API. The method changes based on the chosen backend, user type, and credential type. Proxmox API Permission Scopes \u00b6 To interact with a Proxmox service, the authentication credentials used must have the appropriate permissions. For more information, view the Proxmox documentation on permissions (e.g. PVE Permissions ). HTTPS Backend \u00b6 The HTTPS is the universally accepted backend and supports the most authentication options. To ensure you are only sending your credentials encrypted and to the correct server, make sure to setup a valid SSL certificate and remove verify_ssl=False from your initialization of the ProxmoxAPI object. Username and Password \u00b6 Supported Services: PVE, PMG, PBS Password authentication is the default authentication method and what is used by the web UI. To use this authentication method, the following data is needed: username realm ( pam , pve , etc.) password For the pve realm, the password is set within the API/webUI. For other realms, the password is set in those tools (e.g. for the pam realm, the password is found in /etc/passwd (or really /etc/shadow ) and can be set by running passwd <username> as root). If your user has a One Time Password (OTP) enabled, you will need to add the otp parameter and with your current OTP code to be able to authenticate. This is only required when first authenticating, as long as the requirements for authentication renewal are met (see below). prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>@<realm>', password='<password>', otp='<otp_code>', service='<proxmox_service>', verify_ssl=<True|False>, timeout=<timeout_in_seconds>) For example: prox = ProxmoxAPI('10.10.10.10', user='root@pam', password='password', verify_ssl=False) Renewing Authentication \u00b6 The authentication ticket retrieved using your username/password pair expires after 2 hours. To allow longer usage of proxmoxer, when a request is made close to the expiry of the ticket, the ticket is automatically renewed for another 2 hours. No user interaction is required for renewal and it will automatically be triggered by any request. If long-running usage of proxmoxer is required, the only requirement is to make a request within 2 hours of the most recent request. If the application will already make requests more regularly than 2 hours, no extra requests are needed to keep authentication valid. Any request will trigger an authentication renewal, so a basic GET (e.g. getting version ) every hour or so is enough to keep authentication current. For an alternative, see API Tokens below for a stateless authentication method which allows fine-grain control over permissions and allows authentication expiry. Renewal also does not require OTP codes, so once initially authenticated with an OTP, proxmoxer can continue without user interaction. API Token \u00b6 Supported Services: PVE, PBS The API Token allows stateless interaction with the Proxmox service as well as independent permissions and more flexibility in credential lifecycle management. Abused/leaked API Tokens can be disabled independent of the account with which they are associated and multiple API Tokens can be created for a user, allowing each use its own API Token with only its needed permissions which can be independently managed. prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>@<realm>', token_name='<token_name>', token_value='<token_value>', service='<proxmox_service>', verify_ssl=<True|False>, timeout=<timeout_in_seconds>) For example: prox = ProxmoxAPI('10.10.10.10', user='my_user@pam', token_name='testToken', token_value='41c97f11-b8c6-47db-9886-7fa841e64b6e', verify_ssl=False) OpenSSH Backend \u00b6 Supported Services: PVE, PMG The OpenSSH backend uses OpenSSH to remote into the Proxmox service and run the command using the service's CLI interface. This backend will default to using the config and key of the ssh client (usually in ~/.ssh/ ), so often only needs a host and a user. As this uses SSH to log into the service, it can be considered to use the \"pam\" realm and the specified user must have permission to connect and run the appropriate commands. If the user does not natively have permission to run the required commands, adding an argument of sudo=True will prepend sudo to the command so the specified user can elevate privileges. Minimal Required Arguments \u00b6 prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', backend='openssh') All OpenSSH Arguments \u00b6 prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', port=<port_number>, sudo=<True|False>, forward_ssh_agent=<True|False>, config_file='<path_to_config_file>', identity_file='<path_to_identity_file>', timeout=<timeout_in_seconds>, backend='openssh') For example: prox = ProxmoxAPI('10.10.10.10', user='my_user', sudo=True, backend='openssh') Paramiko \u00b6 Supported Services: PVE, PMG Paramiko is an implementation of SSH completely in Python. This reduces some of the available functionality, but increases portability and reduces dependencies on outside programs. This backend supports password and key authentication. Paramiko uses the following order to attempt authentication: 1 private_key_file SSH Agent Auto-discovered key files Password Key \u00b6 Paramiko defaults to looking for in ~/.ssh for openssh-style key file names. If a private_key_file argument is present, it is used before any keys automatically found. prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', private_key_file='<path_to_file>', backend='ssh_paramiko') Password \u00b6 If a password is provided, usage of an SSH agent is disabled. prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', password='<password>', backend='ssh_paramiko') All Paramiko Arguments \u00b6 prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', password='<password>', port=<port>, private_key_file='<path_to_file>', timeout=<timeout_in_seconds>, sudo=<True|False>, backend='ssh_paramiko') Local \u00b6 The local backend requires no authentication, other than optionally utilizing sudo. prox = ProxmoxAPI(sudo=<True|False>, timeout=<timeout_in_seconds>, backend='local') https://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.connect \u21a9","title":"Authentication"},{"location":"authentication/#authentication","text":"To access a Proxmox service, you must first authenticate with the API. The method changes based on the chosen backend, user type, and credential type.","title":"Authentication"},{"location":"authentication/#proxmox-api-permission-scopes","text":"To interact with a Proxmox service, the authentication credentials used must have the appropriate permissions. For more information, view the Proxmox documentation on permissions (e.g. PVE Permissions ).","title":"Proxmox API Permission Scopes"},{"location":"authentication/#https-backend","text":"The HTTPS is the universally accepted backend and supports the most authentication options. To ensure you are only sending your credentials encrypted and to the correct server, make sure to setup a valid SSL certificate and remove verify_ssl=False from your initialization of the ProxmoxAPI object.","title":"HTTPS Backend"},{"location":"authentication/#username-and-password","text":"Supported Services: PVE, PMG, PBS Password authentication is the default authentication method and what is used by the web UI. To use this authentication method, the following data is needed: username realm ( pam , pve , etc.) password For the pve realm, the password is set within the API/webUI. For other realms, the password is set in those tools (e.g. for the pam realm, the password is found in /etc/passwd (or really /etc/shadow ) and can be set by running passwd <username> as root). If your user has a One Time Password (OTP) enabled, you will need to add the otp parameter and with your current OTP code to be able to authenticate. This is only required when first authenticating, as long as the requirements for authentication renewal are met (see below). prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>@<realm>', password='<password>', otp='<otp_code>', service='<proxmox_service>', verify_ssl=<True|False>, timeout=<timeout_in_seconds>) For example: prox = ProxmoxAPI('10.10.10.10', user='root@pam', password='password', verify_ssl=False)","title":"Username and Password"},{"location":"authentication/#renewing-authentication","text":"The authentication ticket retrieved using your username/password pair expires after 2 hours. To allow longer usage of proxmoxer, when a request is made close to the expiry of the ticket, the ticket is automatically renewed for another 2 hours. No user interaction is required for renewal and it will automatically be triggered by any request. If long-running usage of proxmoxer is required, the only requirement is to make a request within 2 hours of the most recent request. If the application will already make requests more regularly than 2 hours, no extra requests are needed to keep authentication valid. Any request will trigger an authentication renewal, so a basic GET (e.g. getting version ) every hour or so is enough to keep authentication current. For an alternative, see API Tokens below for a stateless authentication method which allows fine-grain control over permissions and allows authentication expiry. Renewal also does not require OTP codes, so once initially authenticated with an OTP, proxmoxer can continue without user interaction.","title":"Renewing Authentication"},{"location":"authentication/#api-token","text":"Supported Services: PVE, PBS The API Token allows stateless interaction with the Proxmox service as well as independent permissions and more flexibility in credential lifecycle management. Abused/leaked API Tokens can be disabled independent of the account with which they are associated and multiple API Tokens can be created for a user, allowing each use its own API Token with only its needed permissions which can be independently managed. prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>@<realm>', token_name='<token_name>', token_value='<token_value>', service='<proxmox_service>', verify_ssl=<True|False>, timeout=<timeout_in_seconds>) For example: prox = ProxmoxAPI('10.10.10.10', user='my_user@pam', token_name='testToken', token_value='41c97f11-b8c6-47db-9886-7fa841e64b6e', verify_ssl=False)","title":"API Token"},{"location":"authentication/#openssh-backend","text":"Supported Services: PVE, PMG The OpenSSH backend uses OpenSSH to remote into the Proxmox service and run the command using the service's CLI interface. This backend will default to using the config and key of the ssh client (usually in ~/.ssh/ ), so often only needs a host and a user. As this uses SSH to log into the service, it can be considered to use the \"pam\" realm and the specified user must have permission to connect and run the appropriate commands. If the user does not natively have permission to run the required commands, adding an argument of sudo=True will prepend sudo to the command so the specified user can elevate privileges.","title":"OpenSSH Backend"},{"location":"authentication/#minimal-required-arguments","text":"prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', backend='openssh')","title":"Minimal Required Arguments"},{"location":"authentication/#all-openssh-arguments","text":"prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', port=<port_number>, sudo=<True|False>, forward_ssh_agent=<True|False>, config_file='<path_to_config_file>', identity_file='<path_to_identity_file>', timeout=<timeout_in_seconds>, backend='openssh') For example: prox = ProxmoxAPI('10.10.10.10', user='my_user', sudo=True, backend='openssh')","title":"All OpenSSH Arguments"},{"location":"authentication/#paramiko","text":"Supported Services: PVE, PMG Paramiko is an implementation of SSH completely in Python. This reduces some of the available functionality, but increases portability and reduces dependencies on outside programs. This backend supports password and key authentication. Paramiko uses the following order to attempt authentication: 1 private_key_file SSH Agent Auto-discovered key files Password","title":"Paramiko"},{"location":"authentication/#key","text":"Paramiko defaults to looking for in ~/.ssh for openssh-style key file names. If a private_key_file argument is present, it is used before any keys automatically found. prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', private_key_file='<path_to_file>', backend='ssh_paramiko')","title":"Key"},{"location":"authentication/#password","text":"If a password is provided, usage of an SSH agent is disabled. prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', password='<password>', backend='ssh_paramiko')","title":"Password"},{"location":"authentication/#all-paramiko-arguments","text":"prox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', password='<password>', port=<port>, private_key_file='<path_to_file>', timeout=<timeout_in_seconds>, sudo=<True|False>, backend='ssh_paramiko')","title":"All Paramiko Arguments"},{"location":"authentication/#local","text":"The local backend requires no authentication, other than optionally utilizing sudo. prox = ProxmoxAPI(sudo=<True|False>, timeout=<timeout_in_seconds>, backend='local') https://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.connect \u21a9","title":"Local"},{"location":"basic_usage/","text":"Basic Usage \u00b6 Proxmoxer is easy to use. After importing the library and creating an instance, interacting with the Proxmox service is simple and follows the API documentation. Importing and Creating an Instance \u00b6 Example Data In the examples below (and in the rest of the documentation), placeholders are used for values which will be different between installations. Anything within <> is a value you will need to change for your environment. There may be some additional examples of what a command might look like with actual values. Any time <> will be used not as placeholders, a note like this will explain the usage for that case. To use Proxmoxer, the library must be imported and a ProxmoxerAPI instance created. This instance takes care of all the authentication, abstraction, and de-serialization of the API calls. from proxmoxer import ProxmoxAPI proxmox = ProxmoxAPI('<host_ip_or_domain>', user='<username>@<realm>', password='<password>', verify_ssl=False) verify_ssl Parameter If you have set up valid SSL certificates, you can remove the verify_ssl=False , but the default self-signed certificates will throw an error without verify_ssl=False . Switching Services or Backends \u00b6 This will default to connecting to a 'PVE' service using the https backend. To change these defaults, specify a service or backend parameter of a supported service and/or a supported backend . e.g. proxmox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', backend='openssh', service='pmg') Changing Ports \u00b6 Proxmoxer (when using the https backend) will use the default port for the selected service to connect to the service. If you need to connect on a different port, adding either the port=<port_number> parameter or adding :<port> to the host can be used. A port in the host will override the port parameter. The port parameter can also be used for the SSH-based backends to change the port used to establish a SSH connection. Making API Calls \u00b6 There are two ways to build API requests: dotted notation and string notation. The format and benefits of each are presented below. Dotted Notation \u00b6 Dotted notation can be thought of as treating the API call as a collection of dicts. This means that you can specify the API endpoint in a pythonic manner and let proxmoxer take care of converting to what the Proxmox service requires. Lets say you want to see what users are available and what containers are on the \"example-node\" node and that prox is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users >>> prox.access.users.get() [{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}] To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc >>> prox.nodes(\"example-node\").lxc.get() [{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}] To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each. >>> # get the list of all the nodes available from the connected node >>> print(proxmox.nodes.get()) [{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}] >>> # use the list of nodes to iterate through each and print the containers and their status >>> for pve_node in proxmox.nodes.get(): ... print(\"{0}:\".format(pve_node['node'])) ... for container in proxmox.nodes(pve_node['node']).lxc.get(): ... print(\"\\t{0}. {1} => {2}\".format(container['vmid'], container['name'], container['status'])) ... example-node: 100. container-a => running 101. container-b => running 105. container-c => running String Notation \u00b6 String notation allows the developer to specify the exact URL path to be used for the API call. This puts more responsibility on the developer to correctly format the path but gives ultimate configurability. The dotted notation examples are displayed below converted into string notation. Lets say you want to see what users are available and what containers are on the \"example-node\" node and that prox is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users >>> prox(\"access/users\").get() [{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}] To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc >>> prox(\"nodes/example-node/lxc\").get() [{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}] To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each. >>> # get the list of all the nodes available from the connected node >>> print(proxmox(\"nodes\").get()) [{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}] >>> # use the list of nodes to iterate through each and print the containers and their status >>> for pve_node in proxmox.nodes.get(): ... print(\"{0}:\".format(pve_node['node'])) ... for container in proxmox(\"nodes/{0}/lxc\".format(pve_node['node'])).get(): ... print(\"\\t{0}. {1} => {2}\".format(container['vmid'], container['name'], container['status'])) ... example-node: 100. container-a => running 101. container-b => running 105. container-c => running Combining Dotted and String Notation \u00b6 There are a few situations where combining the notations is required or more effective. Variable Data \u00b6 As mentioned in the Dotted Notation section, there are times when string notation is needed in combination with dotted notation. Invalid Names In Python \u00b6 Some endpoints in the Proxmox APIs include a hyphen (\"-\"). When using dotted notation, python interprets this as subtraction rather than a hyphen in the name. In this case, string notation can be used for that section of the path and using dotted notation for the rest of the path. For example, if you want to check the status of a command running in a VM, you would need to do the following >>> # using https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/qemu/{vmid}/agent/exec-status >>> prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec\").post(command=\"echo hello\") {'pid': 5413} >>> prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec-status\").get(pid=5413) {'out-data': 'hello\\n', 'exited': 1, 'exitcode': 0} Examples \u00b6 The following are all different ways of calling the same API path and will return the same result. prox.nodes(<node_name>).lxc.get() prox.nodes(<node_name>).get('lxc') prox.get('nodes/%s/lxc' % <node_name>) prox.get('nodes', <node_name>, 'lxc') prox('nodes')(<node_name>).lxc.get() prox(['nodes', <node_name>]).lxc.get() prox(['nodes', <node_name>]).get('lxc') prox('nodes')(<node_name>)('lxc').get()","title":"Basic Usage"},{"location":"basic_usage/#basic-usage","text":"Proxmoxer is easy to use. After importing the library and creating an instance, interacting with the Proxmox service is simple and follows the API documentation.","title":"Basic Usage"},{"location":"basic_usage/#importing-and-creating-an-instance","text":"Example Data In the examples below (and in the rest of the documentation), placeholders are used for values which will be different between installations. Anything within <> is a value you will need to change for your environment. There may be some additional examples of what a command might look like with actual values. Any time <> will be used not as placeholders, a note like this will explain the usage for that case. To use Proxmoxer, the library must be imported and a ProxmoxerAPI instance created. This instance takes care of all the authentication, abstraction, and de-serialization of the API calls. from proxmoxer import ProxmoxAPI proxmox = ProxmoxAPI('<host_ip_or_domain>', user='<username>@<realm>', password='<password>', verify_ssl=False) verify_ssl Parameter If you have set up valid SSL certificates, you can remove the verify_ssl=False , but the default self-signed certificates will throw an error without verify_ssl=False .","title":"Importing and Creating an Instance"},{"location":"basic_usage/#switching-services-or-backends","text":"This will default to connecting to a 'PVE' service using the https backend. To change these defaults, specify a service or backend parameter of a supported service and/or a supported backend . e.g. proxmox = ProxmoxAPI('<host_ip_or_domain>', user='<username>', backend='openssh', service='pmg')","title":"Switching Services or Backends"},{"location":"basic_usage/#changing-ports","text":"Proxmoxer (when using the https backend) will use the default port for the selected service to connect to the service. If you need to connect on a different port, adding either the port=<port_number> parameter or adding :<port> to the host can be used. A port in the host will override the port parameter. The port parameter can also be used for the SSH-based backends to change the port used to establish a SSH connection.","title":"Changing Ports"},{"location":"basic_usage/#making-api-calls","text":"There are two ways to build API requests: dotted notation and string notation. The format and benefits of each are presented below.","title":"Making API Calls"},{"location":"basic_usage/#dotted-notation","text":"Dotted notation can be thought of as treating the API call as a collection of dicts. This means that you can specify the API endpoint in a pythonic manner and let proxmoxer take care of converting to what the Proxmox service requires. Lets say you want to see what users are available and what containers are on the \"example-node\" node and that prox is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users >>> prox.access.users.get() [{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}] To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc >>> prox.nodes(\"example-node\").lxc.get() [{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}] To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each. >>> # get the list of all the nodes available from the connected node >>> print(proxmox.nodes.get()) [{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}] >>> # use the list of nodes to iterate through each and print the containers and their status >>> for pve_node in proxmox.nodes.get(): ... print(\"{0}:\".format(pve_node['node'])) ... for container in proxmox.nodes(pve_node['node']).lxc.get(): ... print(\"\\t{0}. {1} => {2}\".format(container['vmid'], container['name'], container['status'])) ... example-node: 100. container-a => running 101. container-b => running 105. container-c => running","title":"Dotted Notation"},{"location":"basic_usage/#string-notation","text":"String notation allows the developer to specify the exact URL path to be used for the API call. This puts more responsibility on the developer to correctly format the path but gives ultimate configurability. The dotted notation examples are displayed below converted into string notation. Lets say you want to see what users are available and what containers are on the \"example-node\" node and that prox is a correctly initialized ProxmoxerAPI object (for a PVE service in these examples). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/access/users >>> prox(\"access/users\").get() [{'expire': 0, 'realm-type': 'pam', 'enable': 1, 'email': 'admin@example.com', 'userid': 'root@pam'}, {'expire': 0, 'realm-type': 'pve', 'enable': 1, 'userid': 'testing@pve'}] To add variable values like the names of users or nodes, simply add parentheses to the section before the variable and pass in the string to use (as demonstrated below). >>> # this is equivalent to https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/lxc >>> prox(\"nodes/example-node/lxc\").get() [{'cpu': 0, 'netin': 2122469071629, 'maxmem': 4294967296, 'diskread': 0, 'name': 'container-a', 'maxdisk': 4831838208, 'pid': 1098784, 'mem': 241815552, 'type': 'lxc', 'diskwrite': 0, 'netout': 573718142259, 'status': 'running', 'disk': 3100377088, 'swap': 0, 'maxswap': 536870912, 'vmid': '100', 'uptime': 7457751, 'cpus': 4},{'cpu': 0, 'netin': 1234, 'maxmem': 1234, 'diskread': 0, 'name': 'container-b', 'maxdisk': 1234, 'pid': 1234, 'mem': 1234, 'type': 'lxc', 'diskwrite': 0, 'netout': 1234, 'status': 'running', 'disk': 1234, 'swap': 0, 'maxswap': 1234, 'vmid': '101', 'uptime': 1234, 'cpus': 4}] To get all the containers running on all the nodes in a cluster, you can iterate through all the nodes and get the containers running on each. >>> # get the list of all the nodes available from the connected node >>> print(proxmox(\"nodes\").get()) [{'type': 'node', 'node': 'example-node', 'ssl_fingerprint': '63:80:22:...:0D:12', 'id': 'node/example-node', 'status': 'unknown'}] >>> # use the list of nodes to iterate through each and print the containers and their status >>> for pve_node in proxmox.nodes.get(): ... print(\"{0}:\".format(pve_node['node'])) ... for container in proxmox(\"nodes/{0}/lxc\".format(pve_node['node'])).get(): ... print(\"\\t{0}. {1} => {2}\".format(container['vmid'], container['name'], container['status'])) ... example-node: 100. container-a => running 101. container-b => running 105. container-c => running","title":"String Notation"},{"location":"basic_usage/#combining-dotted-and-string-notation","text":"There are a few situations where combining the notations is required or more effective.","title":"Combining Dotted and String Notation"},{"location":"basic_usage/#variable-data","text":"As mentioned in the Dotted Notation section, there are times when string notation is needed in combination with dotted notation.","title":"Variable Data"},{"location":"basic_usage/#invalid-names-in-python","text":"Some endpoints in the Proxmox APIs include a hyphen (\"-\"). When using dotted notation, python interprets this as subtraction rather than a hyphen in the name. In this case, string notation can be used for that section of the path and using dotted notation for the rest of the path. For example, if you want to check the status of a command running in a VM, you would need to do the following >>> # using https://pve.proxmox.com/pve-docs/api-viewer/index.html#/nodes/{node}/qemu/{vmid}/agent/exec-status >>> prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec\").post(command=\"echo hello\") {'pid': 5413} >>> prox.nodes(\"example-node\").qemu(\"103\").agent(\"exec-status\").get(pid=5413) {'out-data': 'hello\\n', 'exited': 1, 'exitcode': 0}","title":"Invalid Names In Python"},{"location":"basic_usage/#examples","text":"The following are all different ways of calling the same API path and will return the same result. prox.nodes(<node_name>).lxc.get() prox.nodes(<node_name>).get('lxc') prox.get('nodes/%s/lxc' % <node_name>) prox.get('nodes', <node_name>, 'lxc') prox('nodes')(<node_name>).lxc.get() prox(['nodes', <node_name>]).lxc.get() prox(['nodes', <node_name>]).get('lxc') prox('nodes')(<node_name>)('lxc').get()","title":"Examples"},{"location":"development/","text":"Development \u00b6 Stub Page This page may be incomplete or contain partial information. Please help improve this page by clicking the edit button above and submitting a Pull Request (PR) to expand this page. Installing from Source \u00b6 Sometimes there are features that have not been added to a published version in PyPI but are in the development source code in Git. You can install directly from the source code branches to test these features or develop more on them. Stability not guaranteed Installing from source control (Git) branches is inherently less stable than installing from PyPI. Installing like this will also not update when new versions or commits are published. Code in source control may be incomplete or broken. No support will be given for issues that arise from installing in this way, however bug reports of broken code are appreciated. There are two main branches to install from: master This branch is what the PyPI versions are built from This branch should be as stable as the PyPI versions, so installing from here is unnecessary develop This branch contains the improvements and new features which will be bundled into a future version This branch should be mostly stable, but can have bugs which are removed before bundled into a version Installing from this branch allows using the latest features and bug testing them To install from source control, use git+https://github.com/proxmoxer/proxmoxer.git@<branch> . You will most likely need to specify the -U ( --upgrade ) flag to overwrite the existing version with the source control version. For example: pip install --upgrade git+https://github.com/proxmoxer/proxmoxer.git@develop More information from installing from source control can be found in the VCS Support pip documentation. Developing using Dev Containers \u00b6 If you use Visual Studio Code for development, you can utilize the great Containers remote to use a containerize development environment. This allows you to use a specific python version or install any packages without interfering with any other development environments you may have. And if you mess anything up or are done contributing, you can simply delete the container and volume and the entire codebase and dependencies are cleaned up. Install Docker ( Instructions ) Install Visual Studio Code ( Instructions ) Install the \"Remote - Containers\" extension Clone this repository into a container ( Instructions ) Wait for the configuration to be loaded, dependencies installed, setup completed, and suggested extensions installed Now you can use the included tasks, linters, and testing support to easily develop on any platform. Developing using Manual Installation \u00b6 If you use another development environment or just don't want to use devcontainers, use the steps below to get started developing Proxmoxer. Install Python 3 ( Instructions ) Install Pip for Python 3 ( Instructions ) clone this repo with git clone https://github.com/proxmoxer/proxmoxer.git and change into the proxmoxer directory Install dependencies with pip3 install --user -r test_requirements.txt -r dev_requirements.txt","title":"Development"},{"location":"development/#development","text":"Stub Page This page may be incomplete or contain partial information. Please help improve this page by clicking the edit button above and submitting a Pull Request (PR) to expand this page.","title":"Development"},{"location":"development/#installing-from-source","text":"Sometimes there are features that have not been added to a published version in PyPI but are in the development source code in Git. You can install directly from the source code branches to test these features or develop more on them. Stability not guaranteed Installing from source control (Git) branches is inherently less stable than installing from PyPI. Installing like this will also not update when new versions or commits are published. Code in source control may be incomplete or broken. No support will be given for issues that arise from installing in this way, however bug reports of broken code are appreciated. There are two main branches to install from: master This branch is what the PyPI versions are built from This branch should be as stable as the PyPI versions, so installing from here is unnecessary develop This branch contains the improvements and new features which will be bundled into a future version This branch should be mostly stable, but can have bugs which are removed before bundled into a version Installing from this branch allows using the latest features and bug testing them To install from source control, use git+https://github.com/proxmoxer/proxmoxer.git@<branch> . You will most likely need to specify the -U ( --upgrade ) flag to overwrite the existing version with the source control version. For example: pip install --upgrade git+https://github.com/proxmoxer/proxmoxer.git@develop More information from installing from source control can be found in the VCS Support pip documentation.","title":"Installing from Source"},{"location":"development/#developing-using-dev-containers","text":"If you use Visual Studio Code for development, you can utilize the great Containers remote to use a containerize development environment. This allows you to use a specific python version or install any packages without interfering with any other development environments you may have. And if you mess anything up or are done contributing, you can simply delete the container and volume and the entire codebase and dependencies are cleaned up. Install Docker ( Instructions ) Install Visual Studio Code ( Instructions ) Install the \"Remote - Containers\" extension Clone this repository into a container ( Instructions ) Wait for the configuration to be loaded, dependencies installed, setup completed, and suggested extensions installed Now you can use the included tasks, linters, and testing support to easily develop on any platform.","title":"Developing using Dev Containers"},{"location":"development/#developing-using-manual-installation","text":"If you use another development environment or just don't want to use devcontainers, use the steps below to get started developing Proxmoxer. Install Python 3 ( Instructions ) Install Pip for Python 3 ( Instructions ) clone this repo with git clone https://github.com/proxmoxer/proxmoxer.git and change into the proxmoxer directory Install dependencies with pip3 install --user -r test_requirements.txt -r dev_requirements.txt","title":"Developing using Manual Installation"},{"location":"setup/","text":"Setup \u00b6 Proxmoxer is easy to setup and has minimal dependencies. Choosing a Backend \u00b6 The required dependencies change depending on the backend (connection method) you will use. The HTTPS backend better matches the details in the Proxmox API documentation, but SSH can be used in an (mostly) interchangeable manner. SSH can be used with complex network environments and can be used with jump hosts. The HTTPS backend can be used through a reverse proxy or any other HTTPS manipulation scheme. For most users, the HTTPS backend will be suitable. The HTTPS backend allows connections for non-PAM realm accounts and supports advanced authentication methods such as API Tokens. It is also universally supported across all current Proxmox products. Unless SSH is specifically required, it is advised to use the HTTPS backend. Installing Dependencies \u00b6 In addition to installing the proxmoxer package via pip, the following packages are required for each backend. https openssh ssh_paramiko pip install requests If you will be uploading files, installing requests_toolbelt will automatically allow larger upload file sizes and reduce memory footprint of an upload pip install openssh_wrapper pip install paramiko You can, of course, install all the dependencies with pip install requests requests_toolbelt openssh_wrapper paramiko to be able to use any of the backends.","title":"Setup"},{"location":"setup/#setup","text":"Proxmoxer is easy to setup and has minimal dependencies.","title":"Setup"},{"location":"setup/#choosing-a-backend","text":"The required dependencies change depending on the backend (connection method) you will use. The HTTPS backend better matches the details in the Proxmox API documentation, but SSH can be used in an (mostly) interchangeable manner. SSH can be used with complex network environments and can be used with jump hosts. The HTTPS backend can be used through a reverse proxy or any other HTTPS manipulation scheme. For most users, the HTTPS backend will be suitable. The HTTPS backend allows connections for non-PAM realm accounts and supports advanced authentication methods such as API Tokens. It is also universally supported across all current Proxmox products. Unless SSH is specifically required, it is advised to use the HTTPS backend.","title":"Choosing a Backend"},{"location":"setup/#installing-dependencies","text":"In addition to installing the proxmoxer package via pip, the following packages are required for each backend. https openssh ssh_paramiko pip install requests If you will be uploading files, installing requests_toolbelt will automatically allow larger upload file sizes and reduce memory footprint of an upload pip install openssh_wrapper pip install paramiko You can, of course, install all the dependencies with pip install requests requests_toolbelt openssh_wrapper paramiko to be able to use any of the backends.","title":"Installing Dependencies"},{"location":"v1_migration/","text":"Migrating from Version 1 \u00b6 There are a few breaking changes between version 1 and version 2. AuthenticationError Moved \u00b6 proxmoxer.backends.https.AuthenticationError was moved to proxmoxer.AuthenticationError (the class itself is the same). Any imports or references to proxmoxer.backends.https.AuthenticationError should be changed to proxmoxer.AuthenticationError . ProxmoxResourceBase Removed \u00b6 While this should be a fully internal change, the ProxmoxResourceBase class was removed. Use ProxmoxResource instead. Removed ProxmoxHTTPTicketAuth \u00b6 The auth_token and csrf_token arguments are no longer supported. If an existing (still valid) token needs to be used, you can pass the token as password and proxmoxer will attempt to renew the ticket and retrieve a new token and CSRF token. Testing changed to pytest \u00b6 The unit testing framework was transitioned from nose to pytest. Any integration with the proxmoxer tests should now call pytest.","title":"v1 to v2"},{"location":"v1_migration/#migrating-from-version-1","text":"There are a few breaking changes between version 1 and version 2.","title":"Migrating from Version 1"},{"location":"v1_migration/#authenticationerror-moved","text":"proxmoxer.backends.https.AuthenticationError was moved to proxmoxer.AuthenticationError (the class itself is the same). Any imports or references to proxmoxer.backends.https.AuthenticationError should be changed to proxmoxer.AuthenticationError .","title":"AuthenticationError Moved"},{"location":"v1_migration/#proxmoxresourcebase-removed","text":"While this should be a fully internal change, the ProxmoxResourceBase class was removed. Use ProxmoxResource instead.","title":"ProxmoxResourceBase Removed"},{"location":"v1_migration/#removed-proxmoxhttpticketauth","text":"The auth_token and csrf_token arguments are no longer supported. If an existing (still valid) token needs to be used, you can pass the token as password and proxmoxer will attempt to renew the ticket and retrieve a new token and CSRF token.","title":"Removed ProxmoxHTTPTicketAuth"},{"location":"v1_migration/#testing-changed-to-pytest","text":"The unit testing framework was transitioned from nose to pytest. Any integration with the proxmoxer tests should now call pytest.","title":"Testing changed to pytest"},{"location":"examples/files/","text":"Files \u00b6 Uploading Files to PVE \u00b6 If you have files on your device which you want to upload to your PVE, it is easy to do. First, to upload large file and to prevent high memory usage, install the requests_toolbelt pip package ( pip install requests_toolbelt ). Next, you will need to open the file you want to upload. f = open(\"<file_path>\", \"rb\") Finally, upload the file specifying the correct content type (\"template\" or \"iso\"). prox.proxmox.nodes('<node_name>').storage('<storage_name>').upload.post(content='<content_type>', filename=f) Downloading Files to PVE \u00b6 As an alternative to downloading a file to your computer and then uploading it to your PVE instance, you can request PVE directly download the file from its URL. Assuming prox is a valid ProxmoxerAPI object and sourceURL is a complete URL of a file to download. content is the same options as above and filename is the name the file will be saved as on the PVE storage. proxmox.nodes(\"<node_name>\").storage(\"<storage_name>\")(\"download-url\").post(url=sourceURL, content=\"<content_type>\", filename=\"<file_name.extension>\") To ensure the file downloaded is the file you expect, you can also specify a hash and algorithm which PVE will check against the file it downloads. proxmox.nodes(\"<node_name>\").storage(\"<storage_name>\")(\"download-url\").post(url=sourceURL, content=\"<content_type>\", filename=\"<file_name.extension>\", checksum=\"<hash>\", \"checksum-algorithm\": \"<md5 | sha1 | sha224 | sha256 | sha384 | sha512>\") This post request will return the UPID of the task created for that download. To wait (block) until a download is complete, see the Blocking Until Task is Complete section.","title":"Sending Files"},{"location":"examples/files/#files","text":"","title":"Files"},{"location":"examples/files/#uploading-files-to-pve","text":"If you have files on your device which you want to upload to your PVE, it is easy to do. First, to upload large file and to prevent high memory usage, install the requests_toolbelt pip package ( pip install requests_toolbelt ). Next, you will need to open the file you want to upload. f = open(\"<file_path>\", \"rb\") Finally, upload the file specifying the correct content type (\"template\" or \"iso\"). prox.proxmox.nodes('<node_name>').storage('<storage_name>').upload.post(content='<content_type>', filename=f)","title":"Uploading Files to PVE"},{"location":"examples/files/#downloading-files-to-pve","text":"As an alternative to downloading a file to your computer and then uploading it to your PVE instance, you can request PVE directly download the file from its URL. Assuming prox is a valid ProxmoxerAPI object and sourceURL is a complete URL of a file to download. content is the same options as above and filename is the name the file will be saved as on the PVE storage. proxmox.nodes(\"<node_name>\").storage(\"<storage_name>\")(\"download-url\").post(url=sourceURL, content=\"<content_type>\", filename=\"<file_name.extension>\") To ensure the file downloaded is the file you expect, you can also specify a hash and algorithm which PVE will check against the file it downloads. proxmox.nodes(\"<node_name>\").storage(\"<storage_name>\")(\"download-url\").post(url=sourceURL, content=\"<content_type>\", filename=\"<file_name.extension>\", checksum=\"<hash>\", \"checksum-algorithm\": \"<md5 | sha1 | sha224 | sha256 | sha384 | sha512>\") This post request will return the UPID of the task created for that download. To wait (block) until a download is complete, see the Blocking Until Task is Complete section.","title":"Downloading Files to PVE"},{"location":"examples/tasks/","text":"Tasks \u00b6 Basic Task Interaction \u00b6 What is a task UPID? \u00b6 Most actions on Proxmox services are backed by tasks. These are visible in the web UI and are created when automation or users request actions be completed. Tasks are uniquely identified by a UPID which follows the format UPID:<node_name>:<pid_in_hex>:<pstart_in_hex>:<starttime_in_hex>:<type>:<id (optional)>:<user>@<realm>: For example UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam: or UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam: . Getting Task IDs \u00b6 The Proxmoxer service instance will maintain a record of all past tasks as well as all currently active tasks. The list of these tasks can be requested. >>> prox.nodes(\"example-node\").tasks.get(limit=3, source=\"all\") [{'id': '103', 'user': 'root@pam', 'pstart': 65597267, 'saved': '0', 'type': 'vzdump', 'pid': 851962, 'upid': 'UPID:example-node:000CFFFA:03E8EF53:619480BA:vzdump:103:root@pam:', 'node': 'example-node', 'starttime': 1637122234, 'status': 'RUNNING'}, {'user': 'root@pam', 'endtime': 1637122161, 'id': '', 'upid': 'UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'node': 'example-node', 'starttime': 1637122156, 'status': 'OK', 'type': 'aptupdate', 'pid': 851036, 'pstart': 65589443}, {'endtime': 1637121960, 'id': '', 'user': 'root@pam', 'pstart': 65550050, 'pid': 848306, 'type': 'vncshell', 'starttime': 1637121762, 'upid': 'UPID:example-node:000CF1B2:03E836E2:61947EE2:vncshell::root@pam:', 'node': 'example-node', 'status': 'OK'}] Additional filters can be found in the documentation . Getting Task Details \u00b6 Each task has associated information on the status of the task and a log of the output of the task. This data can be collected by using the UPID of the task. >>> prox.nodes(\"example-node\").tasks(\"UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").status.get() {'pid': 851036, 'node': 'example-node', 'type': 'aptupdate', 'upid': 'UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'status': 'stopped', 'starttime': 1637122156, 'pstart': 65589443, 'id': '', 'exitstatus': 'OK', 'user': 'root@pam'} >>> prox.nodes(\"example-node\").tasks(\"UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").log.get() [{'n': 1, 't': 'starting apt-get update'}, {'t': 'Hit:1 http://ftp.us.debian.org/debian bullseye InRelease', 'n': 2}, {'n': 3, 't': 'Get:2 http://ftp.us.debian.org/debian bullseye-updates InRelease [39.4 kB]'}, {'t': 'Get:3 http://security.debian.org bullseye-security InRelease [44.1 kB]', 'n': 4}, {'n': 5, 't': 'Get:4 http://download.proxmox.com/debian/pve bullseye InRelease [3053 B]'}, {'t': 'Fetched 86.5 kB in 1s (125 kB/s)', 'n': 6}, {'t': 'Reading package lists...', 'n': 7}, {'t': 'TASK OK', 'n': 8}] The status information (for completed tasks) includes information on who, when, where, and what was done in that task. The log contains a list of dicts which are {'n': <int_of_line_number>, 't': '<line_text>'} , one for each line of output. Tasks in Progress \u00b6 While tasks are active, the status endpoint returns information on the setup and start of the task and a status or \"running\". Blocking Until Task is Complete \u00b6 Many API endpoints will return a task UPID while the task completes in the background. While this can be useful to allow asynchronous execution, often you may desire to wait (block) for a task to finish. The code below provides a (very) basic way of polling the API until the task completes. def basic_blocking_task_status(proxmox_api, task_id, node_name): data = {\"status\": \"\"} while (data[\"status\"] != \"stopped\"): data = proxmox_api.nodes(node_name).tasks(task_id).status.get() return data","title":"Tasks"},{"location":"examples/tasks/#tasks","text":"","title":"Tasks"},{"location":"examples/tasks/#basic-task-interaction","text":"","title":"Basic Task Interaction"},{"location":"examples/tasks/#what-is-a-task-upid","text":"Most actions on Proxmox services are backed by tasks. These are visible in the web UI and are created when automation or users request actions be completed. Tasks are uniquely identified by a UPID which follows the format UPID:<node_name>:<pid_in_hex>:<pstart_in_hex>:<starttime_in_hex>:<type>:<id (optional)>:<user>@<realm>: For example UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam: or UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam: .","title":"What is a task UPID?"},{"location":"examples/tasks/#getting-task-ids","text":"The Proxmoxer service instance will maintain a record of all past tasks as well as all currently active tasks. The list of these tasks can be requested. >>> prox.nodes(\"example-node\").tasks.get(limit=3, source=\"all\") [{'id': '103', 'user': 'root@pam', 'pstart': 65597267, 'saved': '0', 'type': 'vzdump', 'pid': 851962, 'upid': 'UPID:example-node:000CFFFA:03E8EF53:619480BA:vzdump:103:root@pam:', 'node': 'example-node', 'starttime': 1637122234, 'status': 'RUNNING'}, {'user': 'root@pam', 'endtime': 1637122161, 'id': '', 'upid': 'UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'node': 'example-node', 'starttime': 1637122156, 'status': 'OK', 'type': 'aptupdate', 'pid': 851036, 'pstart': 65589443}, {'endtime': 1637121960, 'id': '', 'user': 'root@pam', 'pstart': 65550050, 'pid': 848306, 'type': 'vncshell', 'starttime': 1637121762, 'upid': 'UPID:example-node:000CF1B2:03E836E2:61947EE2:vncshell::root@pam:', 'node': 'example-node', 'status': 'OK'}] Additional filters can be found in the documentation .","title":"Getting Task IDs"},{"location":"examples/tasks/#getting-task-details","text":"Each task has associated information on the status of the task and a log of the output of the task. This data can be collected by using the UPID of the task. >>> prox.nodes(\"example-node\").tasks(\"UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").status.get() {'pid': 851036, 'node': 'example-node', 'type': 'aptupdate', 'upid': 'UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:', 'status': 'stopped', 'starttime': 1637122156, 'pstart': 65589443, 'id': '', 'exitstatus': 'OK', 'user': 'root@pam'} >>> prox.nodes(\"example-node\").tasks(\"UPID:example-node:000CFC5C:03E8D0C3:6194806C:aptupdate::root@pam:\").log.get() [{'n': 1, 't': 'starting apt-get update'}, {'t': 'Hit:1 http://ftp.us.debian.org/debian bullseye InRelease', 'n': 2}, {'n': 3, 't': 'Get:2 http://ftp.us.debian.org/debian bullseye-updates InRelease [39.4 kB]'}, {'t': 'Get:3 http://security.debian.org bullseye-security InRelease [44.1 kB]', 'n': 4}, {'n': 5, 't': 'Get:4 http://download.proxmox.com/debian/pve bullseye InRelease [3053 B]'}, {'t': 'Fetched 86.5 kB in 1s (125 kB/s)', 'n': 6}, {'t': 'Reading package lists...', 'n': 7}, {'t': 'TASK OK', 'n': 8}] The status information (for completed tasks) includes information on who, when, where, and what was done in that task. The log contains a list of dicts which are {'n': <int_of_line_number>, 't': '<line_text>'} , one for each line of output.","title":"Getting Task Details"},{"location":"examples/tasks/#tasks-in-progress","text":"While tasks are active, the status endpoint returns information on the setup and start of the task and a status or \"running\".","title":"Tasks in Progress"},{"location":"examples/tasks/#blocking-until-task-is-complete","text":"Many API endpoints will return a task UPID while the task completes in the background. While this can be useful to allow asynchronous execution, often you may desire to wait (block) for a task to finish. The code below provides a (very) basic way of polling the API until the task completes. def basic_blocking_task_status(proxmox_api, task_id, node_name): data = {\"status\": \"\"} while (data[\"status\"] != \"stopped\"): data = proxmox_api.nodes(node_name).tasks(task_id).status.get() return data","title":"Blocking Until Task is Complete"},{"location":"tools/intro/","text":"Intro to Tools \u00b6 The proxmoxer.tools package is a collection of convenience classes which assist with common use-cases. These classes are not required to use proxmoxer (or even the Proxmox features they support), but provide common code which you would likely just recreate when using the features. Classes \u00b6 Tasks - Interact with Proxmox Tasks and UPIDs","title":"Intro"},{"location":"tools/intro/#intro-to-tools","text":"The proxmoxer.tools package is a collection of convenience classes which assist with common use-cases. These classes are not required to use proxmoxer (or even the Proxmox features they support), but provide common code which you would likely just recreate when using the features.","title":"Intro to Tools"},{"location":"tools/intro/#classes","text":"Tasks - Interact with Proxmox Tasks and UPIDs","title":"Classes"},{"location":"tools/tasks/","text":"Tasks Tools \u00b6 What is a task UPID? \u00b6 Most actions on Proxmox services are backed by tasks. These are visible in the web UI and are created when automation or users request actions be completed. Tasks are uniquely identified by a UPID which follows the format UPID:<node_name>:<pid_in_hex>:<pstart_in_hex>:<starttime_in_hex>:<type>:<id (optional)>:<user>@<realm>: Class Methods \u00b6 The functionality of the Tasks tools class is available through static methods. This means you don not need to instantiate a Tasks object to be able to call the methods. blocking_status \u00b6 Turns getting the status of a Proxmox task into a blocking call by polling the API until the task completes. prox (ProxmoxAPI) - The ProxmoxAPI object to use to query for status task_id (str) - the UPID of the task timeout (float, optional) - If the task does not complete in this time (in seconds) return None, defaults to 300 polling_interval (float, optional) - the time to wait between checking for status updates, defaults to 0.01 Examples \u00b6 >>> from proxmoxer.tools import Tasks >>> from proxmoxer import ProxmoxAPI >>> prox = ProxmoxAPI(\"1.2.3.4\", user=\"root@pam\", password=\"password\", verify_ssl=False) >>> Tasks.blocking_status(prox, \"UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:\") {'pstart': 235991182, 'exitstatus': 'OK', 'pid': 3017066, 'user': 'root@pam', 'starttime': 1669517921, 'upid': 'UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:', 'type': 'vzcreate', 'node': 'hydrogen-pve-0', 'id': '123', 'status': 'stopped'} >>> decode_upid \u00b6 Decodes the sections of a UPID into separate fields upid (str) - a UPID string returns dict of UPID sections upid (str) - the original upid node (str) - the name of the node which started/owns the task pid (int) - the process ID of the task pstart (int) - the relative timestamp of the start of the process starttime (int) - the epoch timestamp of the start of the task type (str) - the type of task represented by the UPID id (str) - an identifier additional to the type (usually the resource (e.g. VM) ID) user (str) - The <user>@<realm> who initiated the task comment (str) - an optional extra field, often not used Examples \u00b6 >>> from proxmoxer.tools import Tasks >>> Tasks.decode_upid(\"UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam:\") {'upid': 'UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam:', 'node': 'example-node', 'pid': 715154, 'pstart': 10623911, 'starttime': 1636572501, 'type': 'vzdump', 'id': '100', 'user': 'root@pam', 'comment': ''} >>> Tasks.decode_upid(\"UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam:\") {'upid': 'UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam:', 'node': 'example-node', 'pid': 2178359, 'pstart': 32287149, 'starttime': 1636789133, 'type': 'aptupdate', 'id': '', 'user': 'root@pam', 'comment': ''} >>> decode_logs \u00b6 Decodes the JSON log of Proxmox tasks to a plain string. Joins the lines with \\n . log_list (dict[]) - the list of log lines which is returned from the Proxmox service returns a string Examples \u00b6 >>> from proxmoxer.tools import Tasks >>> from proxmoxer import ProxmoxAPI >>> l = prox.nodes(\"example-node\").tasks(\"UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:\").log.get() >>> l [{'t': \"extracting archive '/mnt/pve/hl01-files/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst'\", 'n': 1}, {'t': 'Total bytes read: 508579840 (486MiB, 194MiB/s)', 'n': 2}, {'t': 'Detected container architecture: amd64', 'n': 3}, {'t': \"Creating SSH host key 'ssh_host_rsa_key' - this may take some time ...\", 'n': 4}, {'n': 5, 't': 'done: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container'}, {'n': 6, 't': \"Creating SSH host key 'ssh_host_dsa_key' - this may take some time ...\"}, {'n': 7, 't': 'done: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container'}, {'n': 8, 't': \"Creating SSH host key 'ssh_host_ed25519_key' - this may take some time ...\"}, {'n': 9, 't': 'done: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container'}, {'n': 10, 't': \"Creating SSH host key 'ssh_host_ecdsa_key' - this may take some time ...\"}, {'n': 12, 't': 'TASK OK'}, {'t': 'done: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container', 'n': 11}] >>> Tasks.decode_log(l) \"extracting archive '/mnt/pve/nas/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst'\\nTotal bytes read: 508579840 (486MiB, 194MiB/s)\\nDetected container architecture: amd64\\nCreating SSH host key 'ssh_host_rsa_key' - this may take some time ...\\ndone: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container\\nCreating SSH host key 'ssh_host_dsa_key' - this may take some time ...\\ndone: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container\\nCreating SSH host key 'ssh_host_ed25519_key' - this may take some time ...\\ndone: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container\\nCreating SSH host key 'ssh_host_ecdsa_key' - this may take some time ...\\ndone: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container\\nTASK OK\" >>> print(Tasks.decode_log(l)) extracting archive '/mnt/pve/nas/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst' Total bytes read: 508579840 (486MiB, 194MiB/s) Detected container architecture: amd64 Creating SSH host key 'ssh_host_rsa_key' - this may take some time ... done: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container Creating SSH host key 'ssh_host_dsa_key' - this may take some time ... done: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container Creating SSH host key 'ssh_host_ed25519_key' - this may take some time ... done: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container Creating SSH host key 'ssh_host_ecdsa_key' - this may take some time ... done: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container TASK OK >>>","title":"Tasks"},{"location":"tools/tasks/#tasks-tools","text":"","title":"Tasks Tools"},{"location":"tools/tasks/#what-is-a-task-upid","text":"Most actions on Proxmox services are backed by tasks. These are visible in the web UI and are created when automation or users request actions be completed. Tasks are uniquely identified by a UPID which follows the format UPID:<node_name>:<pid_in_hex>:<pstart_in_hex>:<starttime_in_hex>:<type>:<id (optional)>:<user>@<realm>:","title":"What is a task UPID?"},{"location":"tools/tasks/#class-methods","text":"The functionality of the Tasks tools class is available through static methods. This means you don not need to instantiate a Tasks object to be able to call the methods.","title":"Class Methods"},{"location":"tools/tasks/#blocking_status","text":"Turns getting the status of a Proxmox task into a blocking call by polling the API until the task completes. prox (ProxmoxAPI) - The ProxmoxAPI object to use to query for status task_id (str) - the UPID of the task timeout (float, optional) - If the task does not complete in this time (in seconds) return None, defaults to 300 polling_interval (float, optional) - the time to wait between checking for status updates, defaults to 0.01","title":"blocking_status"},{"location":"tools/tasks/#examples","text":">>> from proxmoxer.tools import Tasks >>> from proxmoxer import ProxmoxAPI >>> prox = ProxmoxAPI(\"1.2.3.4\", user=\"root@pam\", password=\"password\", verify_ssl=False) >>> Tasks.blocking_status(prox, \"UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:\") {'pstart': 235991182, 'exitstatus': 'OK', 'pid': 3017066, 'user': 'root@pam', 'starttime': 1669517921, 'upid': 'UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:', 'type': 'vzcreate', 'node': 'hydrogen-pve-0', 'id': '123', 'status': 'stopped'} >>>","title":"Examples"},{"location":"tools/tasks/#decode_upid","text":"Decodes the sections of a UPID into separate fields upid (str) - a UPID string returns dict of UPID sections upid (str) - the original upid node (str) - the name of the node which started/owns the task pid (int) - the process ID of the task pstart (int) - the relative timestamp of the start of the process starttime (int) - the epoch timestamp of the start of the task type (str) - the type of task represented by the UPID id (str) - an identifier additional to the type (usually the resource (e.g. VM) ID) user (str) - The <user>@<realm> who initiated the task comment (str) - an optional extra field, often not used","title":"decode_upid"},{"location":"tools/tasks/#examples_1","text":">>> from proxmoxer.tools import Tasks >>> Tasks.decode_upid(\"UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam:\") {'upid': 'UPID:example-node:000AE992:00A21BA7:618C1D55:vzdump:100:root@pam:', 'node': 'example-node', 'pid': 715154, 'pstart': 10623911, 'starttime': 1636572501, 'type': 'vzdump', 'id': '100', 'user': 'root@pam', 'comment': ''} >>> Tasks.decode_upid(\"UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam:\") {'upid': 'UPID:example-node:00213D37:01ECA9AD:618F6B8D:aptupdate::root@pam:', 'node': 'example-node', 'pid': 2178359, 'pstart': 32287149, 'starttime': 1636789133, 'type': 'aptupdate', 'id': '', 'user': 'root@pam', 'comment': ''} >>>","title":"Examples"},{"location":"tools/tasks/#decode_logs","text":"Decodes the JSON log of Proxmox tasks to a plain string. Joins the lines with \\n . log_list (dict[]) - the list of log lines which is returned from the Proxmox service returns a string","title":"decode_logs"},{"location":"tools/tasks/#examples_2","text":">>> from proxmoxer.tools import Tasks >>> from proxmoxer import ProxmoxAPI >>> l = prox.nodes(\"example-node\").tasks(\"UPID:example-node:002E096A:0E10F08E:6382D261:vzcreate:123:root@pam:\").log.get() >>> l [{'t': \"extracting archive '/mnt/pve/hl01-files/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst'\", 'n': 1}, {'t': 'Total bytes read: 508579840 (486MiB, 194MiB/s)', 'n': 2}, {'t': 'Detected container architecture: amd64', 'n': 3}, {'t': \"Creating SSH host key 'ssh_host_rsa_key' - this may take some time ...\", 'n': 4}, {'n': 5, 't': 'done: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container'}, {'n': 6, 't': \"Creating SSH host key 'ssh_host_dsa_key' - this may take some time ...\"}, {'n': 7, 't': 'done: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container'}, {'n': 8, 't': \"Creating SSH host key 'ssh_host_ed25519_key' - this may take some time ...\"}, {'n': 9, 't': 'done: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container'}, {'n': 10, 't': \"Creating SSH host key 'ssh_host_ecdsa_key' - this may take some time ...\"}, {'n': 12, 't': 'TASK OK'}, {'t': 'done: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container', 'n': 11}] >>> Tasks.decode_log(l) \"extracting archive '/mnt/pve/nas/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst'\\nTotal bytes read: 508579840 (486MiB, 194MiB/s)\\nDetected container architecture: amd64\\nCreating SSH host key 'ssh_host_rsa_key' - this may take some time ...\\ndone: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container\\nCreating SSH host key 'ssh_host_dsa_key' - this may take some time ...\\ndone: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container\\nCreating SSH host key 'ssh_host_ed25519_key' - this may take some time ...\\ndone: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container\\nCreating SSH host key 'ssh_host_ecdsa_key' - this may take some time ...\\ndone: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container\\nTASK OK\" >>> print(Tasks.decode_log(l)) extracting archive '/mnt/pve/nas/template/cache/ubuntu-22.04-standard_22.04-1_amd64.tar.zst' Total bytes read: 508579840 (486MiB, 194MiB/s) Detected container architecture: amd64 Creating SSH host key 'ssh_host_rsa_key' - this may take some time ... done: SHA256:zUpB9ln5sJLrBgjU97LBSNvYItH0ByEU8VXeURfnt1o root@test-container Creating SSH host key 'ssh_host_dsa_key' - this may take some time ... done: SHA256:YAf2Od306G2ACLbJ2wbF1rrzo0q8rZNMZlr8wvCgsMY root@test-container Creating SSH host key 'ssh_host_ed25519_key' - this may take some time ... done: SHA256:O2pIbtFCdPPiY+Q6PnDxJUAmEAc5vaSku+Vg0s6gxkQ root@test-container Creating SSH host key 'ssh_host_ecdsa_key' - this may take some time ... done: SHA256:xz1iY4+3/0jTSZbxWxEkouZvD2VJOfkAsQEFNWh1rIY root@test-container TASK OK >>>","title":"Examples"}]}